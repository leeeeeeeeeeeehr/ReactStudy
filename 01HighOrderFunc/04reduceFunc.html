<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<script>

  /* reduce() 함수
  - 배열을 순회하면서 요소의 값을 하나의 값으로 줄여서 반환한다.
    즉, 반환값은 있으나 배열이 아니라 하나의 결과값만 반환한다.
  - 배열의 크기가 N일 때,
      초기값이 있으면 N회차 반복한다.
      초기값이 없으면 N-1회차 반복한다.
  - 앞에서 사용한 고차함수와 다른 점은 콜백함수의 매개변수가 4개이다. */

  // 콜백함수에서 사용할 초기값이 없고 반환값도 없는 형태
  (function reduceTest1() {
    console.error("reduceTest1() - 기본 사용법");
    var oldArray = [0, 1, 2, 3, 4];
    oldArray.reduce(function(previousVal, currentVal, index, array) {
      /* 초기값이 없으므로 배열의 첫 번째 요소가 prev에 할당된다.
      따라서 curr은 두 번째 요소인 1이 할당된다.
      반환값이 없으므로 두 번째 prev는 undefined가 된다.
      
      할당되는 값 )
      - previousVal: 0, undefined, undefined, undefined
      - currentVal: 1, 2, 3, 4 */
      console.log(previousVal, currentVal, index);
    });
  })();
  /* 이와 같이 함수를 소괄호로 묶어주면 선언과 동시에 호출된다.
  따라서 차후 별도로 호출할 수 없다. 주로 테스트용으로 사용된다. */

  // 콜백함수에서 사용할 초기값은 없지만 반환값은 있는 형태
  function reduceTest2() {
    console.error("reduceTest2() - return 값 사용하기");
    var oldArray = [0, 1, 2, 3, 4];
    var sum = oldArray.reduce(function(previousVal, currentVal) {
      /* 초기값이 없으므로 prev는 배열의 첫 번째 값을 할당받는다.
      이전 루프의 반환값이 다음 루프의 prev의 값이 된다.
      
      할당되는 값 )
      - previousVal: 0, 1, 3, 6
      - currentVal: 1, 2, 3, 4
          => 모든 반복이 완료되면 6 + 4인 10을 반환한다. */
      console.log(previousVal, currentVal);
      return previousVal + currentVal;
    });
    console.log(sum);
  }

  // 콜백함수에서 사용할 초기값도 있고 반환값도 있는 형태
  function reduceTest3() {
    console.error("reduceTest3 - 초기값 사용하기");
    var oldArray = [0, 1, 2, 3, 4];
    var sum = oldArray.reduce(function(previousVal, currentVal) {
      /* 초기값으로 2가 주어졌으므로 prev의 첫 번째 값은 2가 된다.
      따라서 curr의 첫 번째 값은 0이 되고,
      초기값과 반환값이 있으므로 배열의 크기만큼 총 5회 반복한다.

      할당되는 값 )
      - previousVal: 2, 2, 3, 5, 8
      - currentVal: 0, 1, 2, 3, 4
          => 모든 반복이 완료되면 8 + 4인 12를 반환한다. */
      console.log(previousVal, currentVal);
      return previousVal + currentVal;
    }, 2);
    console.log(sum);
  }

  // 반환값과 초기값을 둘 다 가지고있는 콜백함수
  function reduceTest4() {
    console.error("reduceTest4() - 배열에서 중복값을 제거하는 함수 구현");
    var oldArray = [0, 1, 2, 3, 3, 3, 4, 5, 5, 6, 6];
    var newArray = oldArray.reduce(
      /* 초기값으로 빈 배열이 주어졌으므로 prev의 첫 번째 값은 [ ]이 된다.
      배열의 크기만큼 N회차 반복한다.
      
      할당되는 값 )
      - previousVal: [ ], [0], [0, 1], [0, 1, 2], [0, 1, 2, 3], [0, 1, 2, 3], [0, 1, 2, 3],
                     [0, 1, 2, 3, 4], [0, 1, 2, 3, 4, 5], [0, 1, 2, 3, 4, 5],
                     [0, 1, 2, 3, 4, 5, 6]
      - currentVal: 0, 1, 2, 3, 3, 3, 4, 5, 5, 6, 6
      
      위와 같이 반복되다가 검색한 원소가 있다면 false가 되므로 배열에 추가되지 않는다.
      즉, 중복이 제거된 상태의 배열이 최종 반환된다. */
      function(previousVal, currentVal) {
        // 배열에서 특정 원소를 검색해서 찾지 못한 경우 -1이 반환된다.
        if (previousVal.indexOf(currentVal) < 0) {
          previousVal.push(currentVal);
        }
        return previousVal;
      }, []);
    console.log(newArray);
  }
</script>
<body>
  <h2>고차함수 - reduce()</h2>
  <div>
    <!-- 이미 함수를 생성함과 동시에 호출했으므로 별도로 호출할 수 없다. -->
    <input type="button" onclick="reduceTest1();" value="reduce1">
    <!-- 두 번째 함수부터는 정상적으로 호출된다. -->
    <input type="button" onclick="reduceTest2();" value="reduce2">
    <input type="button" onclick="reduceTest3();" value="reduce3">
    <input type="button" onclick="reduceTest4();" value="reduce4">
  </div>
</body>
</html>